<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        let arr_alpha = ["A", "B", "C", "D", "E"];
        //원본배열.slice() : 새로운 배열 return , 원본배열.splice() : 원본배열을 가공하게 된다. 
        
        //1. 원본배열.slice(startIndex, endIndex) 전달인자 startIndex: 시작번지수, endIdnex: 끝나는 번지수
        //startIndex ~ endIndex이전번지수까지를 잘라내서 새로운 배열로 return 

        //2. 원본배열.splice(startIndex, count, arg1, arg2,,,, ) 전달인자 startIndex: 시작번지수, count : 개수, arg1은 시작번지수부터 개수만큼 삭제된 원소 대신에 들어갈 각 배열원소, 
        //ex> 전달인자 (음수,) -1은 마지막
        

        let sliced_arr = arr_alpha.slice(2,4)//2번지부터 3번지(4번지 이전)까지를 잘라낸 원소들을 새로운 배열로 return
        console.log(sliced_arr);

        arr_alpha.splice(1, 3, 'b', 'c', 'd', 'e')//1번지부터 3개를 잘라낸 원본 배열에 새로운 각 원소로 'b'와 'c'와 'd' 그리고 'e'를 배치한다. : 원본배열이 수정이 된다. 
        console.log(arr_alpha);

        let pets = ['강아지', '고양이', '앵무새', '도마뱀', '킹콩', '말'];
        //애완동물과 관계없는 것을 찾아내서 없애야 한다. 
        //console.log(pets);
        //배열.indexOf('value') : 'value'에 해당하는 배열의 번지수를 return
        //배열에 해당하는 'value'가 존재하지 않는다면 -1를 return 


        //pets.splice(pets.indexOf('킹콩'), 1, '원숭이');
        //pets.splice(pets.indexOf('말'), 1 );
        //console.log(pets);

        pets.splice(-2,2);//끝에서 2번째부터 다음 원소(오른쪽편)를 2개 삭제
        console.log(pets);

        //시민 제보에 의해서 사건에 대한 용의자를 제보 받는다. 
        //겹쳐지는 용의자가 있다. 
        let criminal = ['용의자A', '용의자B', '용의자C','용의자A', '용의자A', '용의자B']

        //중복된 용의자가 몇명인지 알 수 없기 때문에 
        //끝을 알 수 없는 반복문을 사용해서 변경한다. 
        let overlap_num = criminal.indexOf('용의자A'); //배열의 각 원소에서 해당하는 값이 여러개가 있다면, 첫번째 번지수를 return한다. 
        //console.log(overlap_num);

        while(criminal.indexOf('용의자A') != -1){
             criminal.splice(criminal.indexOf('용의자A'), 1, '**' );
        }
        criminal.splice(criminal.indexOf('**'), 1, '용의자A'); //첫 번째 것만 변경

        console.log(criminal);

    </script>
</body>
</html>